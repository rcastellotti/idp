\documentclass[IN,11pt,twoside,openright,idp,english]{tumthesis}
\usepackage[backend=bibtex,style=ieee]{biblatex}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{url}
\usepackage{amsmath}
\usepackage[]{hyperref}
\usepackage{xurl}
\usepackage{booktabs}
\usepackage{listings}
\lstset{numbers=none,basicstyle=\footnotesize\ttfamily,breaklines=true}
\usepackage{url}
\usepackage[style=base]{caption}
\captionsetup{font={rm,footnotesize},labelfont={rm}}    
\usepackage[hang]{footmisc}
% \setlength\footnotemargin{5pt}

\titleenglish{Development of a Framework for Retrieval of Parameters of the Starlink Dish}
\titlegerman{Entwurf eines Frameworks zur Informationsgewinnung von Parametern der Starlink Dish}
\author{Roberto Castellotti}
\supervisor{\chairhead}
\assistants{Leander Seidlitz, Johannes Zirngibl}
\advisor{Leander Seidlitz, Johannes Zirngibl}
\courseofstudy{Informatics}
\date{September 15, 2016}
\location{Garching}
\setcounter{tocdepth}{2}
\addbibresource{ref.bib}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  

\begin{document}
\lstset{  
tabsize=2,  
backgroundcolor=\color{lbcolor},  
showstringspaces=false  
}
\pagenumbering{gobble}  
\maketitle
\cleardoublepage

\begin{abstract} 

Starlink is a novel technology offering Internet connection to the most rural areas on our planet thanks to a Low Earth Orbiting satellite constellation.

In this report, we document our work and findings on Starlink-based connections. 
    
After introducing the principles behind Low Earth Orbiting satellites Internet connection and introducing technologies to work on satellites, we investigate whether Starlink-based connections result in a different routing of packets when reaching geographically sparse targets; we move  then to analyzing whether the dish performs some buffering before sending packets to the satellite.
    
Lastly, we analyze satellites visible from a dish and, after developing a script to detect satellite handovers, we move on to trying to correlate drops in bandwidth and satellite handovers; handovers do not seem to happen in a specific pattern, nor are indicative of a drop in bandwidth, this means the connection is very stable from an end-user perspective.
    
While performing our research, we develop tooling to interact with the dish and run measurements.

\end{abstract}
    
\tableofcontents
\listoffigures
\listoftables
\startcontent

\chapter{Introduction and Background}   

\section{Introduction}
    
Starlink \footnote{\url{https://starlink.com}} is the largest Low Earth Orbiting, hereinafter LEO, satellite constellation with more than 4000 satellites currently orbiting around Earth.

SpaceX \footnote{\url{https://spacex.com}} manages it, and its scope is to bring Internet broadband connection to the most remote and rural areas in the world while also serving people living in residential areas, typically using a cabled link.
    
LEO satellites orbit around 550 kilometers from Earth, so naturally, LEO connections have a lower latency than other satellite-based connections. SpaceX claims latency is around approximately 25 ms. Our experiments show that it is often higher (approximately 45ms). 
    
Starlink might not be the best solution for people living in residential areas, as their place is covered by a faster cabled connection, probably way cheaper as the infrastructure is more straightforward to maintain. 
    
As of October 2023, Starlink costs 65 USD per month with a one-time hardware cost of 450 USD. 
    
Satellite-based Internet connections have been around for several years. They are based on geostationary satellites, hereinafter GEOSAT, orbiting at about 35.000 kilometers; it is thus natural to expect higher latency when comparing GEOSAT connections to cabled Internet connections; we are talking about around 600 ms for latency, or in other words, Starlink averages ~70 RTTs in the time a GEOSAT satellite does 1 RTT.
    
From a customer perspective, using Starlink is straightforward; after receiving the hardware package, the only needed thing is to plug the satellite dish (see Figure \ref{fig:dish}) and position it in a place with clear access to the sky. After that, adding in a router is enough to browse the Internet using different devices. 

Our setup is more straightforward; the machine we use to run measurements and use the Starlink connection is directly connected to the dish.
    
On a more technical note, what is happening to packets sent from a local device is they go through the dish, they are relayed to a nearby satellite, and they are sent to a ground station in view; from that point onwards, packets are routed normally through the Internet. A sample ground station is shown in Figure \ref{fig:gs}.
    
SpaceX also experiments with Inter Satellite Links, allowing a dish not in proximity of a Ground Station to communicate by routing packets to different satellites and relaying them back to Earth as soon as it is deemed convenient. This is crucial for the maritime version of the Starlink kit \footnote{\url{https://starlink.com/business/maritime}}, since it is safe to assume oceangoing ships will often be in such condition.

Moreover, it might be possible that using laser links is faster than fiber on Earth, thus providing lower latency connection to everyone, as reported by Elon Musk himself \cite{tweet}.
    
\begin{figure}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/ground-station.jpeg}
    \caption{A sample ground station, from \small\protect\url{https://reddit.com/r/SpaceXLounge/comments/hcf4t5/prototype_starlink_terminal_closeups_merrillan_wi/}}
    \label{fig:gs}
\end{figure}
    
\begin{figure}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/dish.jpeg}
    \caption{Our Starlink dish, located in Garching, Munich, DE}
    \label{fig:dish}
\end{figure}
    
\begin{figure}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/starlink-101.png}
    \caption{Basic Starlink working, from \cite{izhikevich2023democratizing}}
    \label{fig:starlink-101}
\end{figure}
    
SpaceX is currently the most popular LEO-based Internet Service Provider. However, other similar projects exist, such as OneWeb \footnote{\url{https://oneweb.net}} and Amazon Project Kuiper \footnote{\url{https://aboutamazon.com/what-we-do/devices-services/project-kuiper}}. The former is more enterprise and government-focused, while the latter aims to be a Starlink competitor, with the first satellite launches starting now.

The future is bright for LEO-based ISPs; however, we might soon encounter some problems. Starlink alone now has 4306 satellites in orbit, and Project Kuiper plans to launch 3,236; these two constellations alone account for more than 7500 satellites. This is increasing the overall brightness of the skies, and debris proliferation will become more and more of a concern, as reported by \cite{cite-key}.
    
\section{Background}

We will now introduce some concepts we will use later. We will briefly describe the gRPC protocol, as it is used by the dish to communicate diagnostics and statistics to customers, before describing Two Line Element Sets, the data format used to encode the satellite's positions. 

For the measurement parts, we are using standard Unix tools, like \texttt{ping}, \texttt{traceroute}, \texttt{iperf}, and we are using Python for scripting purposes.
    
\subsection{gRPC protocol}
    
gRPC is an RPC framework from Google\footnote{\url{https://grpc.io}}. It is the dish API's protocol and is massively employed across different fields, especially in microservices architectures. 
    
gRPC uses protocol buffers (protobufs) as Interface Definition Language and as a message interchange format; this means every client needs to have a stub providing the methods available on the server. In order to obtain the stub \texttt{.proto} files are usually needed, but the dish employs a technology called \textit{Server Reflection} \footnote{\url{https://github.com/grpc/grpc/blob/master/doc/server-reflection.md}}; this means it is possible to query the API itself to get a list of the available methods.

Using a tool like grpcurl \footnote{\url{https://github.com/fullstorydev/grpcurl}}, it is possible to inspect the service; furthermore, it is easy to use the gRPC python library \footnote{\url{https://pypi.org/project/grpc/}} to develop scripts.
    
\subsection{Two-line Element Sets}
    
Two-line Element Sets (hereinafter TLEs) is a widely used ASCII-based data format to encode the position of orbital elements for a given point in time \footnote{\url{https://en.wikipedia.org/wiki/Two-line_element_set}}. We work with TLEs using the Skyfield Library, \footnote{\url{https://rhodesmill.org/skyfield/}}, an elegant astronomy library for Python. Check Appendix \ref{app:sky} for a sample script to localize a satellite's position given the Satellite Name. A complete list of Starlink satellite names can be found at \url{https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink}. 
SATNAME is a unique identifier.
    
Knowing the position of a satellite at any given time allows us to restrict the subset of satellites the dish may be connected to; it is worth noting that previously, it was possible to call the \texttt{dish\_get\_context} or similar methods on the API to retrieve such information. Unfortunately, these methods either return a \texttt{PermissionDenied} error or are deprecated.
    
\begin{lstlisting}[caption={TLE for satellite STARLINK-1007 },captionpos=b]
STARLINK-1007           
1 44713U 19074A   23239.65120160  .00022666  00000+0  15354-2 0  9991
2 44713  53.0553  19.2809 0001296  68.3392 291.7735 15.06406564209327
\end{lstlisting}
    
\section{Related work}
    
Being Starlink a novel technology the existing body of research is somewhat limited, but papers and tools \footnote{\url{https://github.com/danopstech/starlink\_exporter}}, \footnote{\url{https://github.com/sparky8512/starlink-grpc-tools}} are in development, we created some scripts to work with the dish and to perform some measurements, you can find them in the very same repository that contains this report \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti}}.
    
From a research perspective, different works provide more insights into Starlink â€” papers like \cite{pan2023measuring} focus on describing the infrastructure Starlink uses. In contrast, \cite{izhikevich2023democratizing} illustrates a novel approach to make measurements simpler and cheaper, and \cite{browser-side} focuses on running some client-side measurements with a browser extension.
    
Some work was recently on the hardware side, like \cite{glitching} while \cite{quarkslab} focuses on the firmware perspective and gives some insight into the gRPC API.
    
\section{gRPC API}
    
Our first approach to the dish is through the web UI reachable at 192.168.100.1; we discover it is getting data from a gRPC API running directly on the dish, so we decid to spend some time documenting the available methods we could later use to gather useful additional information.
    
The server-reflected gRPC API is running on the dish; we can access it by querying it at \texttt{192.168.100.1:9200} using grpcurl \footnote{\url{https://github.com/fullstorydev/grpcurl}}, a sample query to retrieve downlink throughput is:
    
\begin{lstlisting}[language=bash]
rc@gnolmir:~$ grpcurl -plaintext -d '{"get_status":{}}' 192.168.100.1:9200 SpaceX.API.Device.Device/Handle
{
    "apiVersion": "10",
    ... (output omitted)
}
\end{lstlisting}
ed
It is then possible to use \texttt{jq} to extract the needed fields. We can use the following command to describe the available services:
    
\begin{lstlisting}[language=bash]
rc@gnolmir:~$ grpcurl -plaintext 192.168.100.1:9200 describe
SpaceX.API.Device.Device is a service:
service Device {
    rpc Handle ( .SpaceX.API.Device.Request ) returns ( .SpaceX.API.Device.Response );
    rpc Stream ( stream .SpaceX.API.Device.ToDevice ) returns ( stream .SpaceX.API.Device.FromDevice );
}
grpc.reflection.v1alpha.ServerReflection is a service:
service ServerReflection {
    rpc ServerReflectionInfo ( stream .grpc.reflection.v1alpha.ServerReflectionRequest ) returns ( stream .grpc.reflection.v1alpha.ServerReflectionResponse );
}
\end{lstlisting}
    
And then describe the single service using:
    
\begin{lstlisting}[language=bash]
rc@gnolmir:~$ grpcurl -plaintext 192.168.100.1:9200 describe SpaceX.API.Device.Request
SpaceX.API.Device.Request is a message:
message Request {
    uint64 id = 1;
    string target_id = 13;
    uint64 epoch_id = 14;
    oneof request {
    .SpaceX.API.Device.SignedData signed_request = 15;
    .SpaceX.API.Device.RebootRequest reboot = 1001;
    .SpaceX.API.Device.SpeedTestRequest speed_test = 1003;
    ... (output omitted)
    }
\end{lstlisting}
    
Here \footnote{\url{https://gist.github.com/rcastellotti/e20630366dfeaeada6cc2680f562f6ac}} is a complete list of available methods as of September 2023.
% verb tenses are ok from here on
To simplify scripting, we develop a simple wrapper library around the gRPC API  \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti/-/blob/main/nine981.py}} and a CLI tool \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti/-/blob/main/s.py}} to use the library in command line. It should be trivial to add functionality to the library.

Unlike \texttt{sparky8512/starlink-grpc-tools}, we do not make any assumptions about the format used to save data.
    
\chapter{Measurements}

After getting acquainted with our working environment, we run several measurements to better understand Starlink internals. 
    
We first try to understand the possible differences in package routing between Starlink-based and default cabled connections. We then move to measure the latency and bandwidth of links, and we also check whether the values for bandwidth reported from the API are the same as our machine reports. Later, we try to understand whether we could spot physical layer influences on the latency of connections.  
    
In the second part of our measurements, we explore the satellite part of the infrastructure. First, we implement tooling to identify visible satellites for our dish and to detect patterns in satellite appearances before implementing a side-channel measurement to detect satellite handovers based on the approach introduced in \cite{izhikevich2023democratizing}.
    
\section{Routing}
    
One of the first experiments we perform is running traceroutes to several different geographically sparse targets; we retrieve a list of those from major cloud vendors, \footnote{\url{ https://gstatic.com/ipranges/cloud.json}}, \footnote{\url{https://ip-ranges.amazonaws.com/ip-ranges.json}}, \footnote{\url{https://microsoft.com/en-us/download/details.aspx?id=53601}}, \footnote{\url{https://docs.oracle.com/en-us/iaas/tools/public_ip_ranges.json }}.
    
The reason why we are using those targets is we know the hosts' location. We can never be sure the last target we reach with a traceroute in complex networks reflects the position of the target we were trying to reach, but it, more often than not, is a good approximation. 
It is almost impossible to understand what happens to a packet entering a private network; cloud vendors often do not answer pings on their hosts to effectively hide it. 
    
We run the traceroutes using ICMP, UDP, and TCP using both the Starlink and the default network interface over several days to see whether we can spot some differences when visualizing them using NetworkX, a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks. \footnote{\url{https://networkx.org/}}. 

We limit ourselves to the first seven hops because we do not receive answers for further hops. 
    
\begin{figure}
    \label{fig:tr_aws_icmp}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/tr_aws_icmp.png}
    \caption{Visualizing traceroutes to 4 different hosts from AWS using ICMP, the left Figure refers to Starlink traceroutes; the right one is the default network interface.}
\end{figure}
    
\begin{figure}
    \label{fig:tr_aws_udp}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/tr_aws_udp.png}
    \caption{Visualizing traceroutes to 4 different hosts from AWS using UDP, the left Figure refers to Starlink traceroutes; the right is the default network interface.}
\end{figure}
    
\begin{figure}
    \label{fig:tr_aws_tcp}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/tr_aws_tcp.png}
    \caption{Visualizing traceroutes to 4 different hosts from AWS using TCP, the left Figure refers to Starlink traceroutes; the right is the default network interface.}
\end{figure}
    
\begin{figure}
    \label{fig:tr_azure_icmp}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/tr_azure_icmp.png}
    \caption{Visualizing traceroutes to 4 different hosts from Azure using ICMP, the left Figure refers to Starlink traceroutes, the right one is the default network interface.}
\end{figure}
    
Traceroutes do not tell us a lot, with a minor exception: we note that routing in Starlink is way more complex; in the "default" traceroutes, we see traffic going to 4 different main directions, while it is much more warped in the Starlink case. This might be caused by several different decisions; it is also possible it is the result of Inter Satellite Routing. 

We are only reporting traceroutes to AWS using the three most common methods and a traceroute to Azure; more data to visualize can be found in the accompanying repository. \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti-data}}
    
We do not find any significant differences comparing traceroutes over different days; we see hops in the same Autonomous Systems; the only difference we are able to observe is we reach different hosts inside AS14593, the Autonomous System SpaceX operates, \footnote{\url{https://bgp.he.net/AS14593}}.
    
The following is a table of hosts reached together and a count of how many times we reached the target.
    
\begin{table}[]
    \centering
    \begin{tabular}{ r r }
        \toprule
            host           & count \\ 
            \midrule
            206.224.65.204 & 595   \\
            206.224.65.200 & 595   \\
            206.224.65.208 & 549   \\ 
            206.224.65.182 & 444   \\
            206.224.65.196 & 440   \\ 
            206.224.65.188 & 360   \\ 
            206.224.65.129 & 358   \\ 
            206.224.65.178 & 274   \\ 
            206.224.65.180 & 235   \\ 
            206.224.65.184 & 189   \\ 
            206.224.65.186 & 159   \\ 
            206.224.65.190 & 151   \\
            \bottomrule
    \end{tabular}
    \caption{Targets reached inside AS14593 together with the count}
\end{table}
    
We also see some different prefixes in later traceroutes; AS14593 advertises many. The previous table is just a snapshot at a given moment.
    
\section{Latency Analysis}

The gRPC API exposes a \texttt{get\_status} method containing a \texttt{pop\_ping\_latency\_ms} field, so we decided to measure the stability of latency to the PoP (Point of Presence). 

We know that in AS14593, there are several geographically distributed hosts containing "pop" in their hostname, such as \texttt{customer.dnvrcox1.pop.starlinkisp.net}, the naming scheme suggests the position of the PoP we are analyzing, in the previous example it is located in Denver, Colorado. Here \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti-data/-/blob/main/pops.json}} is a brief list of different PoPs retrieved using censys \footnote{\url{https://search.censys.io/}}.

Latency to the PoP is pretty stable, as SpaceX reports it fluctuates around 35 ms, as we can verify from Figure \ref{fig:vis-latency}. We were not able to detect any patterns in latency fluctuation.

\begin{figure}
    \centeringed
    \includegraphics[width=1\columnwidth]{img/latency.png}
    \caption{Visualizing latency to the Point of Presence.}
    \label{fig:vis-latency}
\end{figure}

\section{Bandwidth analysis}

During our investigations, we analyze bandwidth for two reasons: first, we want to check whether the data from the API was correct, and then we want to see whether we could detect any patterns in bandwidth drops.

The first experiment we set up is the following: We start downloading five Debian ISOs from different mirrors (to neutralize the effect of the single upload speed of a mirror). While downloading the files, we are also running a script to extract downlink throughput from the dish and measuring it simply by getting data from \path{/sys/class/net/{interface}/statistics/rx_bytes} in order to compare the data reported from the API and the actual bandwidth our machine reports.

Figure \ref{fig:vis-bw-15sec} contains our results, \texttt{bandwidth\_bps} is the data we obtain from \path{/sys/class/net/{interface}/statistics/rx_bytes}, while \texttt{downlink\_throughput\_bps} is the data reported from the gRPC API. As we can see, the two values are very similar; this suggests that the dish reports bandwidth correctly.

From \cite{llc-application}, we know the dish seeks better connections, as satellites move constantly, every 15 seconds. We plot vertical lines every 15 seconds and shift them to detect whether the bandwidth drops were happening in 15-second intervals.

\begin{figure}
    \centering
    \includegraphics[width=1.0\columnwidth]{img/bw-15seconds.png}
    \caption{Bandwidth visualization, with vertical red lines every 15 seconds.}
    \label{fig:vis-bw-15sec}
\end{figure}

We repeat the experiments by shifting the red vertical lines and changing the intervals for collected data, and in the majority of cases, we see that whenever we draw a vertical red line, we have some drop in the immediate milliseconds before or after; however, drops also happen in different intervals. We thought these drops might be related to satellite handovers, so we investigated further; check Section \ref{sec:sat-hand-drop}, where we try to correlate satellite handovers (retrieved using a side-channel) and drops in bandwidth. 

\section{Physical layer influences on latency}

After measuring latency and bandwidth and noticing some drops in semi-regular intervals, we decide to investigate whether the physical layer had any influences on latency in some way; our intuition is that if this is the case, we can approximately detect the buffer size; this means in the best-case scenario we send the packet we want to reach the Internet exactly, it fills the buffer and it is sent immediately, worst case scenario we send the packet when the previous packet was just sent and we need to wait to fill a certain buffer before sending the packet. Of course this operation introduces in worst-case scenario some performance drawbacks.

To verify this hypothesis, we try to send some payload with iPerf \footnote{\url{https://iperf.fr/}} on the network interface used by Starlink. We send payloads of increasing sizes (10k, 20k, 50k, 100k, 1M, 10M) and measure the RTT; the following is a visualization, as we can notice that sending some traffic does not have an impact.

\begin{figure}
    \centering
    \includegraphics[width=0.6\columnwidth]{img/latency_iperf.png}
    \caption{Latency variation while sending traffic on the uplink using iPerf}
\end{figure}

\section{Visible Satellites}
One of the first operations on satellites for use is to retrieve the subset of satellites the dish migth be connected to.

It is up to us to define what "visible" means; in our evaluations, we decide that, knowing the satellites orbit around Earth at around 550 kilometers, it is reasonable to assume a satellite is visible when it is above the horizon, and it is (point to point) not further than 800 kilometers. The ground truth might be different, but this approximation allows us to have an idea about what is going on in space. 

The first measurement we set up is the following: every 15 seconds, we run a script that gets all the "visible" satellites and stores them in a SQLite database. If we see the same satellite in the iteration before we update the \texttt{timestamp} otherwise, we create a new row in the database. We use a \texttt{relative\_ts} (relative timestamp) to enumerate every measurement (a probe every 15 seconds). To measure visible satellites, we are running the following script: \texttt{python3 visible-satellites.py -lat 48.2489 -lon 11.6532 -el 0 -d 800}, where \texttt{lat} and \texttt{lon} are Garching's coordinates, we are not interested in using an elevation. The script can be found in the repository containing this report.

\section{Patterns in Satellites Appearances}

After having collected data for several hours, we decide to plot satellite appearances to check whether they are following some patterns; it seems like this is the case, as shown in Figure \ref{fig:vis-sat-pat}. We see the same satellite every 12 hours roughly. For some satellites, we notice some artifacts that might induce thinking there is a change in the pattern, but this is not true; the interval between the appearances is the same as in the other cases; we are not sure we understand why we are seeing this.

\begin{figure}
    \centering
    \includegraphics[width=1.0\columnwidth]{img/visualizing-how-long-satellites-are-visible-for.png}
    \caption{Visualizing patterns in satellite appearances, we roughly see the same satellite every 12 hours.}
    \label{fig:vis-sat-pat}
\end{figure}

\section{Detecting Satellite Handovers}

Unfortunately, as mentioned earlier, it is impossible to know from the gRPC API which satellite the dish is connected to. It used to be possible during the pre-beta phase \footnote{\url{https://reddit.com/r/Starlink/comments/p84o5i/comment/h9o1elp/}}.

The Starlink gRPC API, however, exposes a \texttt{dish\_get\_obstruction\_map} method. Following the approach described in \cite{izhikevich2023democratizing}, we use the information gathered from polling the endpoint each second to extract the current obstruction map and visualize satellite handovers. This works because the dish adds a dot (setting a value to 1) in a 123*123 matrix whenever it sees a satellite in that position. 

The matrix is cleared whenever the dish is rebooted by setting every entry to -1; whenever a satellite is detected, the entry is set to 1. 

By polling the endpoint frequently enough, we can observe satellite traces, and by comparing values in the matrices we obtain, we can detect whether a satellite handover was performed.

Let us assume the following matrices are retrieved at $ t_x $ and $ t_{x+1} $, respectively. 
In the first matrix, we have ones in $ (0,2) $ and $ (1,3) $; in the second one, we have ones in $ (0,2) $, $ (1,3) $, $ (2,4) $. This means the new satellite we saw at $ t_{x+1} $ is on the same path as the satellites before. Thus, NO handover was performed. \vspace{10mm}

$\begin{bmatrix}
-1 & -1 & \color{red}1 &           -1 & -1 \\
-1 & -1 &           -1 & \color{red}1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\ 
\end{bmatrix}
+
\begin{bmatrix}
-1 & -1 & \color{red}1 &           -1 &           -1 \\
-1 & -1 &           -1 & \color{red}1 &           -1 \\
-1 & -1 &           -1 &           -1 & \color{red}1 \\
-1 & -1 &           -1 &           -1 &           -1 \\
-1 & -1 &           -1 &           -1 &           -1 \\
\end{bmatrix}
=
\begin{bmatrix}
-2 & -2 & 2 &  -2 &           -2 \\
-2 & -2 & -2 &  2 &           -2 \\
-2 & -2 & -2 & -2 & \color{red}0 \\
-2 & -2 & -2 & -2 &            -2 \\
-2 & -2 & -2 & -2 &            -2 \\
\end{bmatrix}$ \vspace{10mm}

In this different case, the new satellite we see at $ t_{x+1} $ is in a different location, so a handover must have been performed. \vspace{10mm}
ed
$\begin{bmatrix}
-1 & -1 & \color{red}1 &           -1 & -1 \\
-1 & -1 &           -1 & \color{red}1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
\end{bmatrix}
+
\begin{bmatrix}
-1 & -1 & \color{red}1 &           -1 & -1 \\
-1 & -1 &           -1 & \color{red}1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
-1 & -1 &           -1 &           -1 & -1 \\
1 & -1 &            -1 &           -1 & -1 \\
\end{bmatrix}
=ed
\begin{bmatrix}
          -2 & -2 & 2 & -2 & -2 \\
          -2 & -2 & -2 & 2 & -2 \\
          -2 & -2 & -2 & -2 & -2 \\
          -2 & -2 & -2 & -2 & -2 \\
\color{red}0 & -2 & -2 & -2 & -2 \\
\end{bmatrix}$

\vspace{10mm}

We can observe it is pretty easy to detect whether a handover was performed; it is sufficient to sum the two matrices and check whether the $ 0 $ value (there was -1 before, and we currently have 1) is near an entry whose value is $ 2 $ (at $ t_{x} $ value was 1, and at $ t_{x+1} $ value is $ 1 $). 
ed
First, we must  write a script to extract obstruction maps from the dish. To achieve this goal, we can use the \texttt{nine981.get\_obstruction\_map} \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti/-/blame/main/nine981.py\#L26}} function, which returns a JSON response similar to this:

\begin{lstlisting}[caption={data from the \texttt{dish\_get\_obstruction\_map} function},captionpos=b]

{'apiVersion': '9',
 'dishGetObstructionMap': {'minElevationDeg': 10.0,
                           'numCols': 123,
                           'numRows': 123,
                           'snr': [-1.0,
                                   -1.0,
                                   -1.0,
                                   1.0,
                                   1.0,
                                   -1.0,
                                   -1.0,
                ...,
                                   1.0,
                                   1.0,
                                   1.0,
                                   -1.0,\label{sec:sat-hand-drop}

                                   -1.0,
                                   -1.0,
                                   -1.0]}}  
\end{lstlisting}

Now we can extract the values in \texttt{map["dishGetObstructionMap"]["snr"]} and reshape the array in a $123\times123$ with \texttt{np.array(map).reshape(123, 123)}. This allows us to visualize the obstruction map at any given moment; it is a matter of loading the JSON file we want to visualize and plot it with matplotlib \cite{Hunter:2007}, code can be found in Listing \ref{listing-obs} and the visualization is Figure \ref{fig:vis-single-map}.

\begin{lstlisting}[language=python,caption={visualizing a single obstruction map},captionpos=b,label=listing-obs]
import json
import numpy as np
import matplotlib.pyplot as plt
ed
f = "1692089163.json"
map = json.load(open(f))
map = map["dishGetObstructionMap"]["snr"]
map = np.array(map).reshape(123, 123)
plt.imshow(map)
plt.show()
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width=0.5\columnwidth]{img/single_map.png}
    \caption{Visualizing a single obstruction map, satellite traces are clearly visible.}
    \label{fig:vis-single-map}
\end{figure}

Following this approach, we can create a simple script to retrieve maps each second and save them locally; later, we can export images and create a video to better analyze what is going on. 

\section{Correlating Satellite Handovers and Drops in Bandwidth}
\label{sec:sat-hand-drop}

We create a simple script to algorithmically detect handovers; we can use the function \texttt{common.detect\_handovers} \footnote{\url{https://gitlab.lrz.de/netintum/teaching/tumi8-theses/idp-castellotti/-/blob/main/common.py?ref_type=heads\#L263}} to detect whether a handover was performed between two subsequent snapshots; getting all the handovers is simply a matter of iterating for every JSON file we saved and running the function on each pair.

We now correlate satellite handovers (the vertical dashed lines) with the bandwidth measurements we obtained before; we assume we might have bandwidth drops during handovers. 

\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{img/correlation_handovers_bw.png}
    \caption{Trying to correlate satellite handovers (red vertical lines) with bandwidth measurements.}
    \label{fig:vis-correlation-handovers}
\end{figure}

As we can verify from Figure \ref{fig:vis-correlation-handovers}, handovers do not seem to impact bandwidth drops.


\chapter{Final Remarks and Future Work}

Let us now wrap up our experiments; the main takeaways are: latency to the Point of Presence seems to be stable and low enough for network-heavy programs, such as online video games; the average customer, provided he has clear sky access, is usually more than satisfied with Starlink's performances, bandwidth is sustained, and handovers have no impact on it. A dish generally sees approximately eight satellites at any moment and internally decides which one to connect to. In the future, this number may vary following new launches.

Unfortunately, it is impossible to gain further insights regarding the infrastructure of the Autonomous System SpaceX operates; hosts do not answer pings and traceroutes are not indicative of the path packets take. 

Another well-protected link in the chain is the dish itself; many of the methods available are protected and not accessible to the end-user or are deprecated.
Logging in with SSH is futile, as illustrated in the following Figure.

\begin{figure}
    \centering
    \includegraphics[width=1\columnwidth]{img/ssh.png}
    \caption{An attempt to log into the dish using SSH}
    \label{fig:ssh}
\end{figure}

Recently (6 October  2023), Project Kuiper launched the first satellites in orbit for their constellation, and on 16 October, they confirmed the first two satellites are fully activated, generating power and communicating with mission operations center \footnote{\url{https://aboutamazon.com/news/innovation-at-amazon/amazon-project-kuiper-test-satellites-space-launch-october-2023-update}}.

Further work might include running the same measurements we ran over time to monitor changes in this in-development piece of technology, especially it might be interesting to see if latency gets lower after the launch of more satellites and if traceroutes do change or strange paths are seen as a result of routing decisions from different operators.

The exact measurements we ran on Starlink's dish may be run on Project Kuiper dishes as soon as they are commercialized. We have no information about the dish, but it is reasonable to assume it will have a similar API to access data on the dish.

Adding an IPv6-compatible router and trying to reach the dish from the outside might help run other measurements, as suggested in \cite{izhikevich2023democratizing}.

Another interesting topic of research could be Inter Satellite Links; it might be possible to detect if packets are relayed between satellites by examining the first hop after the Starlink Autonomous System (i.e., where the packets exit the SpaceX infrastructure), a reason to perform ISL routing is it might be cheaper for SpaceX to move the packet inside their AS and exit it where they have favorable agreements with other service providers.


\appendix
\chapter{Appendix}

\begin{lstlisting}[language=python,caption={the \texttt{calculate\_visible\_satellites} function},captionpos=b]
def calculate_visible_satellites(
    observer_latitude, observer_longitude, observer_elevation, distance_km
):
    stations_url = "https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink&FORMAT=tle"
    ed
    satellites = load.tle_file(stations_url)
    observer = Topos(observer_latitude, observer_longitude, observer_elevation)
    ts = load.timescale()
    t = ts.now()

    # Calculate satellite positions
    positions = []
    for sat in satellites:
        satellite = sat
        position = (satellite - observer).at(t)
        positions.append((sat, position))

    # Filter visible satellites
    visible_satellites = []
    for sat, position in positions:
        alt, az, distance = position.altaz()
        # Satellite is above the horizon
        if alt.degrees > 0 and distance.km < distance_km:
            visible_satellites.append((sat, alt, az))

    return visible_satellites
\end{lstlisting}

\chapter{Skyfield Library}
\label{app:sky}

\begin{lstlisting}[language=python,caption={retrieving a Satellite's position using the Satname},captionpos=b]

from skyfield.api import load, wgs84

stations_url = "https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink&FORMAT=tle"
satellites = load.tle_file(stations_url)
print("Loaded", len(satellites), "satellites")
by_name = {sat.name: sat for sat in satellites}
satellite = by_name["STARLINK-1007"]

# year, month, day, hour, minute, second
ts = load.timescale()
t = ts.now()
a = satellite.at(t)
lat, lon = wgs84.latlon_of(a)
print("Latitude:", lat)
print("Longitude:", lon)
\end{lstlisting}

\clearpage
\pagestyle{thesischapter}
\cleardoublepage
\selectlanguage{english}
\printbibliography[heading=bibintoc]
\clearpage
\pagestyle{empty}
\end{document}